<!DOCTYPE html>
<html lang="en">
<head>
    <style>
    #popupModal { display: none !important; }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marlin Configurator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
</head>
<body>
    <div class="container mt-5">
        <ul class="nav nav-tabs mb-4">
            <li class="nav-item">
                <a class="nav-link" href="/start-here">Start Here</a>
            </li>
            <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="/configurator">Configurator</a>
            </li>
        </ul>
        <h1>Marlin Configurator</h1>
        <div class="mb-3">
            <label for="configExampleSelect" class="form-label fw-bold">Select the configuration example to edit:</label>
            <select id="configExampleSelect" class="form-select w-auto">
                <option value="">-- Select --</option>
                <option value="btt-skr-cr6-with-btt-tft">btt-skr-cr6-with-btt-tft</option>
                <option value="btt-skr-cr6-with-btt-tft-biqu-h2">btt-skr-cr6-with-btt-tft-biqu-h2</option>
                <option value="btt-skr-cr6-with-btt-tft-e3d-hemera">btt-skr-cr6-with-btt-tft-e3d-hemera</option>
                <option value="btt-skr-cr6-with-stock-creality-tft">btt-skr-cr6-with-stock-creality-tft</option>
                <option value="btt-skr-cr6-with-stock-creality-tft-biqu-h2">btt-skr-cr6-with-stock-creality-tft-biqu-h2</option>
                <option value="btt-skr-cr6-with-stock-creality-tft-neopixel">btt-skr-cr6-with-stock-creality-tft-neopixel</option>
                <option value="cr10-smart-btt-skr-cr6-with-btt-tft">cr10-smart-btt-skr-cr6-with-btt-tft</option>
                <option value="cr10-smart-btt-skr-cr6-with-stock-creality-tft">cr10-smart-btt-skr-cr6-with-stock-creality-tft</option>
                <option value="cr6-max-btt-skr-cr6-with-btt-tft">cr6-max-btt-skr-cr6-with-btt-tft</option>
                <option value="cr6-max-btt-skr-cr6-with-stock-creality-tft">cr6-max-btt-skr-cr6-with-stock-creality-tft</option>
                <option value="cr6-max-stock-mb">cr6-max-stock-mb</option>
                <option value="cr6-se-v4.5.2-mb">cr6-se-v4.5.2-mb</option>
                <option value="cr6-se-v4.5.2-mb-no-watchdog">cr6-se-v4.5.2-mb-no-watchdog</option>
                <option value="cr6-se-v4.5.3-mb">cr6-se-v4.5.3-mb</option>
            </select>
            <div id="fileListArea" class="mt-2"></div>
        </div>
        <form id="configForm" method="POST" enctype="multipart/form-data" class="d-flex flex-wrap align-items-center gap-2 mb-2" action="/edit">
            <input class="form-control form-control-sm w-auto" type="file" id="configFile" name="configFile" accept=".h,.ini,.txt" style="max-width:220px; display:none;">
            <input class="form-control form-control-sm w-auto" type="url" id="configUrl" name="configUrl" placeholder="Paste config URL" style="max-width:220px; display:none;">
            <input type="hidden" name="filename" value="{{ config_source.split('/')[-1] if config_source else 'configuration.h' }}">
            <input type="hidden" name="editedConfig" id="editedConfigHidden">
            <button type="button" class="btn btn-success btn-sm ms-2" id="saveDownloadBtn">Save and Download</button>
        </form>
        <hr>
        <div class="small text-muted mb-2"><strong>Loaded file:</strong> {% if config_source %}{{ config_source }}{% else %}None{% endif %}</div>
        <div id="configEditor">
            <h2 class="mt-4">Edit {% if config_source %}{{ config_source|replace('https://','')|replace('github.com/','')|replace('raw.githubusercontent.com/','')|replace('blob/','')|replace('/','_') }}{% else %}Configuration{% endif %}</h2>
            <div class="mb-2 d-flex flex-wrap align-items-center gap-2">
                <input type="checkbox" id="hideComments" onclick="refreshFilters()">
                <label for="hideComments" class="me-2 mb-0">Hide Comments</label>
                <label for="topicFilter" class="me-2 mb-0">Show:</label>
                <select id="topicFilter" onchange="refreshFilters()" class="form-select form-select-sm w-auto">
                    <option value="all">All Settings</option>
                    <option value="nozzle">Nozzle Temperature</option>
                    <option value="bed">Bed Temperature</option>
                    <option value="motors">Motors</option>
                    <option value="enable">Enable Settings</option>
                    <option value="setting">#define Sttings</option>
                    <option value="commented_define">Commented #define</option>
                </select>
                <label for="searchTerm" class="me-2 mb-0">Keyword Filter:</label>
                <input type="text" id="searchTerm" class="form-control form-control-sm w-auto" placeholder="Type to filter..." oninput="refreshFilters()" style="max-width:140px;">
                <button type="button" class="btn btn-outline-secondary btn-sm ms-2" onclick="viewInContext()">View in Context</button>
                <button type="button" class="btn btn-primary btn-sm ms-2" onclick="saveEditorContent()">Save</button>
            </div>
            <div style="position:relative; width:100%; height:400px;">
                <textarea class="form-control" name="editedConfig" id="configTextarea" rows="20" style="font-family:monospace; resize:vertical; height:100%; min-height:100%; box-sizing:border-box;">{{ config_content if config_content else '' }}</textarea>
            </div>
        </div>
    </div>
    <script>
    // Robust file list display logic
    function restoreEditorState() {
        const filename = localStorage.getItem('lastConfigFilename');
        const folder = localStorage.getItem('lastConfigFolder');
        const content = localStorage.getItem('lastConfigContent');
        if (filename && folder && content) {
            let textarea = document.getElementById('configTextarea');
            if (textarea) {
                textarea.value = content;
                originalConfig = content;
                editedConfig = content;
                filteredConfig = content;
            }
            let hiddenFilename = document.querySelector('input[name="filename"]');
            if (hiddenFilename) hiddenFilename.value = filename;
            let loadedFileDiv = document.querySelector('.small.text-muted.mb-2');
            if (loadedFileDiv) loadedFileDiv.innerHTML = `<strong>Loaded file:</strong> ${folder}/${filename}`;
        }
    }
    function fetchAndRenderFileList() {
        let select = document.getElementById('configExampleSelect');
        let fileListArea = document.getElementById('fileListArea');
        if (!select || !fileListArea || !select.value) {
            fileListArea.innerHTML = '';
            return;
        }
        fileListArea.innerHTML = '<span class="text-muted">Loading files...</span>';
        fetch(`/list-config-files?folder=${encodeURIComponent(select.value)}`)
            .then(response => response.json())
            .then(data => {
                if (Array.isArray(data.files) && data.files.length > 0) {
                    let html = '<ul class="list-group list-group-flush">';
                    for (let file of data.files) {
                        html += `<li class="list-group-item file-list-item" style="cursor:pointer;" data-filename="${file}">${file}</li>`;
                    }
                    html += '</ul>';
                    fileListArea.innerHTML = html;
                    // Use event delegation for robust click handling
                    fileListArea.onclick = function(e) {
                        let item = e.target.closest('.file-list-item');
                        if (!item) return;
                        let filename = item.getAttribute('data-filename');
                        let folder = select.value;
                        // Fetch file content via AJAX
                        fetch(`/edit?folder=${encodeURIComponent(folder)}&filename=${encodeURIComponent(filename)}`)
                            .then(response => response.json())
                            .then(data => {
                                if (data && typeof data.content === 'string') {
                                    // Update editor with new file content
                                    let textarea = document.getElementById('configTextarea');
                                    if (textarea) {
                                        textarea.value = data.content;
                                        originalConfig = data.content;
                                        editedConfig = data.content;
                                        filteredConfig = data.content;
                                        // Optionally update filename hidden input
                                        let hiddenFilename = document.querySelector('input[name="filename"]');
                                        if (hiddenFilename) hiddenFilename.value = filename;
                                    }
                                    // Optionally update loaded file display
                                    let loadedFileDiv = document.querySelector('.small.text-muted.mb-2');
                                    if (loadedFileDiv) loadedFileDiv.innerHTML = `<strong>Loaded file:</strong> ${folder}/${filename}`;
                                    // Persist state for workflow continuity
                                    persistEditorState(filename, folder, data.content);
                                    // Reset filters
                                    if (topicFilter) topicFilter.value = 'all';
                                    if (searchTerm) searchTerm.value = '';
                                    if (hideComments) hideComments.checked = false;
                                    updateSaveButtonVisibility();
                                } else {
                                    alert('Error loading file content.');
                                }
                            })
                            .catch(() => {
                                alert('Error loading file content.');
                            });
                    };
                } else {
                    fileListArea.innerHTML = '<span class="text-muted">No files found in this folder.</span>';
                }
                // Ensure popup is removed after file list updates
                setTimeout(function() {
                    let popup = document.getElementById('popupModal');
                    if (popup) popup.parentNode.removeChild(popup);
                    let backdrops = document.getElementsByClassName('modal-backdrop');
                    while (backdrops.length > 0) {
                        backdrops[0].parentNode.removeChild(backdrops[0]);
                    }
                    document.body.style.overflow = '';
                }, 50);
            })
            .catch(() => {
                fileListArea.innerHTML = '<span class="text-danger">Error loading file list.</span>';
            });
    // FIX: Remove stray closing brace here
    function persistEditorState(filename, folder, content) {
        localStorage.setItem('lastConfigFilename', filename || '');
        localStorage.setItem('lastConfigFolder', folder || '');
        localStorage.setItem('lastConfigContent', content || '');
    }
    function restoreEditorState() {
        const filename = localStorage.getItem('lastConfigFilename');
        const folder = localStorage.getItem('lastConfigFolder');
        const content = localStorage.getItem('lastConfigContent');
        if (filename && folder && content) {
            let textarea = document.getElementById('configTextarea');
            if (textarea) {
                textarea.value = content;
                originalConfig = content;
                editedConfig = content;
                filteredConfig = content;
            }
            let hiddenFilename = document.querySelector('input[name="filename"]');
            if (hiddenFilename) hiddenFilename.value = filename;
            let loadedFileDiv = document.querySelector('.small.text-muted.mb-2');
            if (loadedFileDiv) loadedFileDiv.innerHTML = `<strong>Loaded file:</strong> ${folder}/${filename}`;
        }
    }
    function fetchAndRenderFileList() {
        let select = document.getElementById('configExampleSelect');
        let fileListArea = document.getElementById('fileListArea');
        if (!select || !fileListArea || !select.value) {
            fileListArea.innerHTML = '';
            return;
        }
        fileListArea.innerHTML = '<span class="text-muted">Loading files...</span>';
        fetch(`/list-config-files?folder=${encodeURIComponent(select.value)}`)
            .then(response => response.json())
            .then(data => {
                if (Array.isArray(data.files) && data.files.length > 0) {
                    let html = '<ul class="list-group list-group-flush">';
                    for (let file of data.files) {
                        html += `<li class="list-group-item file-list-item" style="cursor:pointer;" data-filename="${file}">${file}</li>`;
                    }
                    html += '</ul>';
                    fileListArea.innerHTML = html;
                    // Use event delegation for robust click handling
                    fileListArea.onclick = function(e) {
                        let item = e.target.closest('.file-list-item');
                        if (!item) return;
                        let filename = item.getAttribute('data-filename');
                        let folder = select.value;
                        // Fetch file content via AJAX
                        fetch(`/edit?folder=${encodeURIComponent(folder)}&filename=${encodeURIComponent(filename)}`)
                            .then(response => response.json())
                            .then(data => {
                                if (data && typeof data.content === 'string') {
                                    // Update editor with new file content
                                    let textarea = document.getElementById('configTextarea');
                                    if (textarea) {
                                        textarea.value = data.content;
                                        originalConfig = data.content;
                                        editedConfig = data.content;
                                        filteredConfig = data.content;
                                        // Optionally update filename hidden input
                                        let hiddenFilename = document.querySelector('input[name="filename"]');
                                        if (hiddenFilename) hiddenFilename.value = filename;
                                    }
                                    // Optionally update loaded file display
                                    let loadedFileDiv = document.querySelector('.small.text-muted.mb-2');
                                    if (loadedFileDiv) loadedFileDiv.innerHTML = `<strong>Loaded file:</strong> ${folder}/${filename}`;
                                    // Persist state for workflow continuity
                                    persistEditorState(filename, folder, data.content);
                                    // Reset filters
                                    if (topicFilter) topicFilter.value = 'all';
                                    if (searchTerm) searchTerm.value = '';
                                    if (hideComments) hideComments.checked = false;
                                    updateSaveButtonVisibility();
                                } else {
                                    alert('Error loading file content.');
                                }
                            })
                            .catch(() => {
                                alert('Error loading file content.');
                            });
                    };
                } else {
                    fileListArea.innerHTML = '<span class="text-muted">No files found in this folder.</span>';
                }
                // Ensure popup is removed after file list updates
                setTimeout(function() {
                    let popup = document.getElementById('popupModal');
                    if (popup) popup.parentNode.removeChild(popup);
                    let backdrops = document.getElementsByClassName('modal-backdrop');
                    while (backdrops.length > 0) {
                        backdrops[0].parentNode.removeChild(backdrops[0]);
                    }
                    document.body.style.overflow = '';
                }, 50);
            })
            .catch(() => {
                fileListArea.innerHTML = '<span class="text-danger">Error loading file list.</span>';
            });
    }
    }
    let originalConfig = null;
    let editedConfig = null;
    let filteredConfig = null;
    let lastFilteredLine = null;
    // Always define filter controls at top for global use
    let searchTerm = null;
    let topicFilter = null;
    let hideComments = null;

    // Force popup to be hidden and removed repeatedly after page load
    (function forceRemovePopupAndBackdrop() {
        function hideAndRemovePopupAndBackdrop() {
            let popup = document.getElementById('popupModal');
            if (popup) {
                popup.style.display = 'none';
                if (popup.parentNode) popup.parentNode.removeChild(popup);
            }
            // Remove any modal-backdrop overlays
            let backdrops = document.getElementsByClassName('modal-backdrop');
            while (backdrops.length > 0) {
                backdrops[0].parentNode.removeChild(backdrops[0]);
            }
            // Reset body overflow if locked
            document.body.style.overflow = '';
        }
        // Try repeatedly for 2 seconds after page load
        let tries = 0;
        let maxTries = 20;
        let interval = setInterval(function() {
            hideAndRemovePopupAndBackdrop();
            tries++;
            if (tries >= maxTries) clearInterval(interval);
        }, 100);
    })();

    document.addEventListener('DOMContentLoaded', function() {
    // Restore last editor state if present
    restoreEditorState();
    // Always refresh file list after restoring state
    fetchAndRenderFileList();
    // File list logic
    let select = document.getElementById('configExampleSelect');
    let fileListArea = document.getElementById('fileListArea');
    // Assign filter controls globally
    searchTerm = document.getElementById('searchTerm');
    topicFilter = document.getElementById('topicFilter');
    hideComments = document.getElementById('hideComments');
    // Remove popup and backdrop overlays robustly
    function removePopupCompletely() {
        let popup = document.getElementById('popupModal');
        if (popup) popup.parentNode.removeChild(popup);
        let backdrops = document.getElementsByClassName('modal-backdrop');
        while (backdrops.length > 0) {
            backdrops[0].parentNode.removeChild(backdrops[0]);
        }
        document.body.style.overflow = '';
    }
    // Always fetch file list on folder change and page load
    function handleFolderChange() {
        fetchAndRenderFileList();
        setTimeout(removePopupCompletely, 100);
    }
    if (select) {
        select.addEventListener('change', handleFolderChange);
        // On page load, fetch file list if a folder is already selected
        if (select.value) {
            handleFolderChange();
        } else {
            fileListArea.innerHTML = '';
            removePopupCompletely();
        }
    }

        // Initialize config variables
        const textarea = document.getElementById('configTextarea');
        if (textarea) {
            originalConfig = textarea.value;
            editedConfig = textarea.value;
            filteredConfig = textarea.value;
            textarea.addEventListener('input', function() {
                editedConfig = this.value;
                originalConfig = this.value;
                // Autosave to localStorage after every edit
                let filename = document.querySelector('input[name="filename"]')?.value || '';
                let folder = document.getElementById('configExampleSelect')?.value || '';
                persistEditorState(filename, folder, this.value);
            });
        }
        // Restore full edited text when filter changes to 'all'
        if (topicFilter) {
            topicFilter.addEventListener('change', function() {
                if (this.value === 'all' && textarea) {
                    textarea.value = editedConfig;
                    filteredConfig = editedConfig;
                }
            });
        }
        // Save and Download button logic
        const saveDownloadBtn = document.getElementById('saveDownloadBtn');
        if (saveDownloadBtn) {
            saveDownloadBtn.onclick = function() {
                // Always update hidden input with current textarea value before download
                const textarea = document.getElementById('configTextarea');
                const hidden = document.getElementById('editedConfigHidden');
                if (textarea && hidden) {
                    hidden.value = textarea.value;
                }
                // Submit the form
                document.getElementById('configForm').submit();
            };
        }
        // Initial Save button visibility
        updateSaveButtonVisibility();
        // Update Save button visibility on filter changes
        if (topicFilter) topicFilter.addEventListener('change', updateSaveButtonVisibility);
        if (searchTerm) searchTerm.addEventListener('input', updateSaveButtonVisibility);
        if (hideComments) hideComments.addEventListener('change', updateSaveButtonVisibility);
    });
    function refreshFilters() {
        const textarea = document.getElementById('configTextarea');
        let lines = editedConfig ? editedConfig.split('\n') : originalConfig.split('\n');
        let filtered = lines;
        // Hide comments
        if (hideComments && hideComments.checked) {
            let temp = [];
            let inBlock = false;
            for (let line of filtered) {
                let trimmed = line.trim();
                if (trimmed.startsWith('/*')) inBlock = true;
                if (!inBlock && !trimmed.startsWith('//')) temp.push(line);
                if (inBlock && trimmed.endsWith('*/')) inBlock = false;
            }
            filtered = temp;
        }
        // Topic filter
        if (topicFilter && topicFilter.value !== 'all') {
            const keywords = {
                nozzle: ['NOZZLE', 'TEMP_SENSOR', 'HEATER', 'HOTEND'],
                bed: ['BED', 'TEMP_SENSOR_BED', 'HEATER_BED'],
                motors: ['MOTOR', 'STEPPER', 'AXIS'],
                enable: ['ENABLE '],
                setting: ['#define']
            };
            if (topicFilter.value === 'setting') {
                filtered = filtered.filter(line => line.trim().startsWith('#define'));
            } else if (topicFilter.value === 'commented_define') {
                if (!hideComments || !hideComments.checked) {
                    filtered = filtered.filter(line => line.trim().startsWith('//') && line.includes('#define'));
                } else {
                    filtered = [];
                }
            } else {
                filtered = filtered.filter(line => {
                    for (let key of keywords[topicFilter.value]) {
                        if (line.toUpperCase().includes(key)) return true;
                    }
                    return false;
                });
            }
        }
        // Keyword filter
        let searchTermValue = searchTerm ? searchTerm.value.trim().toLowerCase() : '';
        if (searchTermValue) {
            filtered = filtered.filter(line => line.toLowerCase().includes(searchTermValue));
        }
        // Update textarea
        if (textarea) {
            textarea.value = filtered.join('\n');
        }
        updateSaveButtonVisibility();
    }
    function saveEditorContent() {
        const hidden = document.getElementById('editedConfigHidden');
        if (textarea) {
            editedConfig = textarea.value;
            originalConfig = textarea.value;
            if (hidden) hidden.value = textarea.value;
            alert('Changes saved.');
        }
    }
    function updateSaveButtonVisibility() {
        const saveBtn = document.querySelector('button.btn-primary');
        if (saveBtn) {
            if (
                topicFilter && topicFilter.value === 'all' &&
                searchTerm && searchTerm.value.trim() === '' &&
                hideComments && !hideComments.checked
            ) {
                saveBtn.style.display = '';
            } else {
                saveBtn.style.display = 'none';
            }
        }
    }
    function viewInContext() {
        const textarea = document.getElementById('configTextarea');
        if (!textarea) return;
        // Get selected filtered line
        const pos = textarea.selectionStart;
        const filteredLines = textarea.value.split('\n');
        const filteredLineNum = textarea.value.substr(0, pos).split('\n').length - 1;
        const selectedLineContent = filteredLines[filteredLineNum]?.trim();
        // Clear all filters
        if (topicFilter) topicFilter.value = 'all';
        if (searchTerm) searchTerm.value = '';
        if (hideComments) hideComments.checked = false;
        // Restore full config
        textarea.value = originalConfig;
        // Restore full config
        textarea.value = originalConfig;
        // Sync hidden input and editedConfig with full config
        const hidden = document.getElementById('editedConfigHidden');
        if (hidden) hidden.value = originalConfig;
        editedConfig = originalConfig;
        // Find and select the line in the full config
        const originalLines = originalConfig.split('\n');
        let idx = originalLines.findIndex(line => line.trim() === selectedLineContent);
        if (idx >= 0) {
            let start = 0;
            for (let i = 0; i < idx; i++) start += originalLines[i].length + 1;
            let end = start + originalLines[idx].length;
            textarea.focus();
            textarea.setSelectionRange(start, end);
            const lineHeight = textarea.scrollHeight / originalLines.length;
            textarea.scrollTop = lineHeight * (idx - 5);
        }
        updateSaveButtonVisibility();
    }
    </script>
    <script src="/static/popup.js"></script>
    <script>
    // No-op: popup removal now handled by forceRemovePopup above
    </script>
</body>
</html>